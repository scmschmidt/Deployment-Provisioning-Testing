#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Deploys a cloud infrastructure by using terraform and the project
https://github.com/scmschmidt/simple_deployment.

This script gets called by `dpt` and relies on the following:

- It gets called with either 'deploy' or 'destroy' as the 
  first (and only) parameter.

- The current directory contains a YAML file 'config', containing
  the infrastructure description.

- The current directory can freely used. Besides 'config' only the files
  'stdout' and 'stderr' exists and are maintained by `dtp`, which writes
  there the output of this command.

- The exit code defines, if this script was successful or not.

- Messages shall be written to stdout, errors to stderr.
  The `dtp` program will capture both and write them in to the 
  files mentioned before.

- The provider must create a YAML file called 'result' in the current
  directory, which contains the IP addresses of the deployed machines.
  The `dtp` program will process the data further.


Exitcodes:

    0   Everything went fine.
    1   Something went wrong

Ideas:
    - 
    - 

ToDo:
    - Schema needs improvement



Changelog:
----------
01.08.2022      v0.1        - and so it begins...
"""

import datetime
import os
import schema
import sys
import time
import random
import yaml


VERSION = 'v0.1'
AUTHOR = 'soeren.schmidt@suse.com'

def log(text: str, level: str='info' ) -> None:
    """
    Prints the text to stdout or stderr preceded by a timestamp. 
    """
    dest = sys.stderr if level in ['err','error'] else sys.stdout
    print(f'[{datetime.datetime.now()}] {text}', file=dest)

def bye(rc: int=0) -> None:
    """
    Logs termination message and exits with given exit code.
    """

    log(f'Terminating with exit code {rc}')
    sys.exit(rc)

def load_and_vaildate(config_file: str) -> dict:
    """
    Loads the config file (YAML) into a dictionary and validates it
    against a schema afterwards.

    Terminates with error message and exit code 1 on failure.
    """

    # Load config
    try: 
        with open(config_file) as f:
            content = yaml.safe_load(f)
    except Exception as err:
        log(f'Error reading landscape: {err}', 'err')
        sys.exit(1)
    log(f'Landscape "{config_file} loaded successfully.')

    # Check for an empty config.
    if not content:
        log(f'The landscape "{config_file}" is empty!', 'err')
        sys.exit(1)

    # Validate against schema.
    config_schema = schema.Schema({
        'build_dir': str,
        'provider_dir': str,
        'config': {
            'name': str,            # APPLY CLOUD PROVIDER AND HOSTNAME RESTRICTIONS
            schema.Optional('admin_user'): schema.Regex('^.*$'),      # USER NAME RESTRICTIONS
            'admin_user_key': str,
            schema.Optional('enable_root_login'): bool,
            schema.Optional('keymap'): str,
            schema.Optional('location'): str,
            'provider': str,
            schema.Optional('provisioner'): str,
            schema.Optional('registration_server'): str,
            schema.Optional('subnet'): schema.Regex('^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2}$',
                                                    error='Must be a subnet declaration in the form: A.B.C.D/M'),
            schema.Optional('subscription_registration_key'): str,
            'hosts': [{
               'count': schema.And(int, 
                                    lambda n: True if isinstance(n, int) and n >= 1 else False,
                                    error='"count" must be an integer greater than 1'),
                schema.Optional('size'): str,
                schema.Optional('os'): str
            }]
        }

    }, ignore_extra_keys=False)
    try:
        config_schema.validate(content)
    except schema.SchemaError as se:
        msgs = ['Errors during schema validation:'] 
        for err in se.errors + se.autos:
            if err:
                msgs.append(err)
        log('\n\t'.join(msgs), 'err')
        sys.exit(1)
    log('Schema validation passed.')

    return content


def main():

    # Print greeting.
    log(f'''Running: {' '.join(sys.argv)} (Pid: {os.getpid()})''')

    # Load and validate configuration file.
    config = load_and_vaildate('config')

    log(config)


    # Create terraform plan from templates.

    # Do we do a terraform init????

    # Depending on the command, we apply or destroy.

    # Create result file.

    # Do something.
    time.sleep(random.randint(1,3))
    rc = random.randint(0,1) 
    if rc != 0:
        log('I had issues!', 'err')
    else:
        log('fertig')



    # Say good bye.
    bye(rc)


if __name__ == '__main__':
    main()